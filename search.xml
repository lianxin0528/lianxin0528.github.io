<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java：final关键字</title>
    <url>/2020/09/30/Java%20final/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　final是Java中的一个关键字，可以修饰类、方法、成员变量和局部变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 修饰内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123; <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;&#125; &#125;</span><br><span class="line"><span class="comment">// 修饰方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 修饰成员变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> filed = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 修饰方法参数（局部变量）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> String filed)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>　　当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你<strong>永远不会</strong>让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<p>　　final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此方法不能被重写（可以重载多个final修饰的方法）。此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。也就是说子类是不能够存在和父类一模一样的方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(String filed)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">extendFinalClass</span> <span class="keyword">extends</span> <span class="title">FinalClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 因为父类为private方法，子类无法继承到，所以这是子类全新的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 可以重载父类的final方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 报错：override method is final</span></span><br><span class="line"><span class="comment">//	public final void method2(String filed) &#123;&#125;</span></span><br><span class="line">	<span class="comment">// 报错：override method is final</span></span><br><span class="line"><span class="comment">//	public void method2(String filed) &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后补充一句就是所有的private方法都会被隐式指定为final。</p>
<p>　　final成员变量表示常量，只能被赋值一次，赋值后值不再改变。当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求的值是<strong>地址的值</strong>不发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> filed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 引用不可变</span></span><br><span class="line">		<span class="keyword">final</span> FinalClass2 fc = <span class="keyword">new</span> FinalClass2();</span><br><span class="line">		System.out.println(fc.filed); <span class="comment">// 输出0</span></span><br><span class="line">		fc.filed = <span class="number">1</span>;</span><br><span class="line">		System.out.println(fc.filed); <span class="comment">// 输出1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="为什么要使用final"><a href="#为什么要使用final" class="headerlink" title="为什么要使用final?"></a>为什么要使用final?</h4><p>　　我们利用final加以修饰，无外乎两个原因，一个是设计原因，一个是效率原因，这是由于在不同的环境下final 有着不同的语义，所以可能会带来它的一些误解与误用。</p>
<ul>
<li><p><strong>设计原因</strong></p>
<p>　　从设计的角度来考虑为final类，此时final 的语义表明为：<strong>这个类不想在关系结构上做出任何的改变，也不希望有任何人可以继承自这个类，除此之外，就没有更多的限制了。</strong>例如：JDK中提供的基本数据包装类和String类就是final类。以上是我们从类的设计角度来考虑类被final 修饰的情况。此时，我们还需要注意一点，一个类被final之后，它就禁止了继承关系，那么一个这个类中的所有方法都是final修饰的，因为他们不会再被重写了。</p>
</li>
<li><p><strong>效率原因</strong></p>
<p>　　在我们说明final如何在效率上起到作用的时候，我们首先需要掌握一个知识点，即<strong>方法的内联</strong>。我们在掌握了这个知识点之后，可能对于对于final 修饰方法也就一并掌握了。我们要说明final为一个类（Class）带来效率上的好处，还真的得研究到蛮深入的地步，这个深入的地步可以到JVM对于方法的调用处理，也可以深入到寄存器如何存储指令，在这里我们就一切从简的说。</p>
</li>
</ul>
<p>　　一个类被final修饰后，它的方法默认被修饰为final ，这时方法的内联起到作用了。对于Java语言的编译器来说，我们无需刻意地利用内联做什么，编译器会自动地进行函数内联优化。什么是方法的内联呢？一句话直白的说就是把函数调用的方法直接内嵌到方法内部，减少函数调用的次数。实际就是（copy + replace）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = car.getPrice();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    z = car.getPrice();</span><br><span class="line">    discount = y - z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联之后的代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = car.price;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    z = car.price;</span><br><span class="line">    discount = y - z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种很典型的空间换时间的策略。</p>
<h4 id="final修饰域（Field）"><a href="#final修饰域（Field）" class="headerlink" title="final修饰域（Field）"></a>final修饰域（Field）</h4><p>​        final修饰域无外乎两种，一种是基本数据类型的数据域，一种是引用类型。首先是基本数据类型，这个是最常见的使用方法了。用法很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORDER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fee = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​        我认为final修饰基本数据类型的时候是最能体现final语义的一个用法。 出于以下两点考虑的时候，我们就要用final来修饰一个基本数据类型。</p>
<ol>
<li><p>程序编译期间的常量，它永远不会变。</p>
</li>
<li><p>在运行期间为一个final修饰的域初始化一个值，不希望它会发生变化。</p>
</li>
</ol>
<p>这两点对应代码块中的第一条和第二条。在这里补充一点堆、栈和常量池的相关知识。</p>
<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/20/eYKk91aBnxVJzFi.png" alt="堆栈图" style="zoom: 90%;" />

<p>​        一个被final修饰的域就会被放在常量池中，这么做的原因就是为了提高效率。常量值装在需要计算的过程中，让它们充当类似于宏的身份，换句话说，编译器可以在编译期间提前完成一些计算工作，省去了在运行时对于变量的相对复杂的操作。对于static和没有static修饰的基本数据类型来说，是有差异的，差异就在于static修饰的域是在类载入的时候进行初始化的，所有实例共享同一个常量，同时Java虚拟机没有把它当作类变量，在使用它的任何类的常量池或者字节码流中直接存放的是它表示的常量值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码块展示初始化过程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// static final 只能在这里初始化或直接赋值</span></span><br><span class="line">  <span class="keyword">static</span> &#123; a = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="comment">// 动态代码块初始化</span></span><br><span class="line">  &#123; b = <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="comment">// 构造函数初始化</span></span><br><span class="line">  DateTest()&#123; c = <span class="number">3</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        对于引用类型来说，如果有final修饰一个引用类型变量，不是说明这个引用类型指向的实际地址的对象不可变，而是说这个引用不能再指向其他地址的对象，而对象本身是可以改变的。前面也说差不多，这确实有点迷惑。不过问题也不大，就说明一个变量的引用不能变而已，被固定了。对于这点，我就不做过多的解释了。</p>
<h4 id="final修饰方法参数"><a href="#final修饰方法参数" class="headerlink" title="final修饰方法参数"></a>final修饰方法参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalField</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FinalFieldClass ffc = <span class="keyword">new</span> FinalField().getObject(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">    System.out.println(ffc.getStr());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FinalFieldClass <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalFieldClass() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// variable &#x27;str&#x27; is accessed from within inner class, needs to be declare final</span></span><br><span class="line">        <span class="comment">// 变量&#x27;str&#x27;是从内部类内部访问的，需要声明为final</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalFieldClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getStr</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        final修饰方法参数，这里使用内部类来举例。我们跟着main函数执行顺序走，首先创建了一个<code>FinalField</code>对象，调用这个对象的<code>getObject()</code>方法，获取一个对象返回。假设现在这个<code>getObject()</code>方法没有加<code>final</code>关键字。首先将<code>str</code>压栈，创建了一个<code>FinalFieldClass</code>子类对象并返回。此时<code>getObject()</code>方法结束了，返回一个<code>ffc</code>对象，相应的局部变量就应该弹栈，也就是说<code>str</code>出栈了，栈中没有了<code>str</code>。那么问题来了，我现在去调用用<code>ffc</code>对象去调用<code>getStr()</code>方法。就获取不到对应的值了。但是JVM不会这么做，他会在弹出<code>str</code>的时候，就会拷贝一份<code>str</code>的值，当我们创建<code>FinalFieldClass</code>对象时将这个值存放在名为<code>str</code>的变量中，编译器必须检测对局部变量的访问，为每一个变量建立对应的数据域，并将局部变量拷贝到构造器中。</p>
<p>​        那么我们将方法参数列表中的变量修饰为final的，防止了这个变量<strong>在方法中被修改</strong>，因此就做到了局部变量与在内部类建立的拷贝副本保持了一致。但是java8中可以不显示的使用final修饰。</p>
<h3 id="final在多线程"><a href="#final在多线程" class="headerlink" title="final在多线程"></a>final在多线程</h3><p>​        上面讲述的内容都是属于java的基础层面。后面我们看看在多线程中的final，final会进行怎么样的重排序，是否会导致线程安全问题。</p>
<h4 id="final域重排序规则"><a href="#final域重排序规则" class="headerlink" title="final域重排序规则"></a>final域重排序规则</h4><p>　　重排序是编译器或者CPU的代码的结构重排序，达到最佳效果。举个简单的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">int</span> a1 = x * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = y * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = y * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重排序之后的代码</span></span><br><span class="line"><span class="keyword">int</span> a1 = x * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = y * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = y * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>CPU只读一次的x和y值。不需反复读取寄存器来交替x和y值。</p>
<p>　　在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两初次读一个包含final域对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
<h5 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> a;  <span class="comment">// 普通域</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b; <span class="comment">// final域</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> FinalDemo finalDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>; <span class="comment">// 1.写普通域</span></span><br><span class="line">    b = <span class="number">2</span>; <span class="comment">// 2.写final域</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finalDemo = <span class="keyword">new</span> FinalDemo();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FinalDemo demo = finalDemo; <span class="comment">// 3.读对象引用</span></span><br><span class="line">    <span class="keyword">int</span> a = demo.a;    <span class="comment">// 4.读普通域</span></span><br><span class="line">    <span class="keyword">int</span> b = demo.b;    <span class="comment">// 5.读final域</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设线程A在执行<code>writer()</code>方法，线程B执行<code>reader()</code>方法。</p>
<p>　　在写一个final域的时候，JMM会禁止将写final的代码重排序到构造函数之外。通过在写final域之后和构造函数完成之前添加一个storestore内存屏障来实现。当线程A调用调用<code>writer()</code>方法时，首先创建一个<code>FinalDemo</code>对象，并将这个对象的引用赋值给<code>finalDemo</code>。如果现在线程B没有重排序，可能执行的时序图如下：</p>
<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/20/VFJ3A1Uu9cYMODx.png" alt="可能时序" style="zoom: 67%;" />



<p>​        由于a,b之间没有数据依赖性，普通域（普通变量）a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值（零值），这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。在读一个final域的时候，根据前面的规则，就是3一定会发生在5之前。</p>
<h5 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span>[] arrays;</span><br><span class="line">  <span class="keyword">private</span> FinalReferenceDemo finalReferenceDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    arrays = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];  <span class="comment">//1</span></span><br><span class="line">    arrays[<span class="number">0</span>] = <span class="number">1</span>;        <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finalReferenceDemo = <span class="keyword">new</span> FinalReferenceDemo(); <span class="comment">//3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    arrays[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finalReferenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//5</span></span><br><span class="line">      <span class="keyword">int</span> temp = finalReferenceDemo.arrays[<span class="number">0</span>];  <span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        针对引用数据类型，final域写针对编译器和处理器重排序<strong>增加</strong>了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。</p>
<p>​        线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论。</p>
<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/20/t5SVqZvUldzFke4.png" alt="可能时序" style="zoom:80%;" />

<p>​        由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>基本数据类型:</strong><br>        final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。<br>        final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。</p>
<p><strong>引用数据类型：</strong><br>        额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序</p>
<p>​        final类型的变量可以保证在多线程发布某个对象时，这个对象的final域变量能够被正常的初始化（在写final变量后加了storestore屏障，在读final变量前加了loadload屏障），而普通类型的变量可能不会被正确的初始化，这样导致该对象在多个线程之间出现不一致的情况，这也就是我们所说的引用溢出。罪魁祸首是处理器重排序，因为处理器重排序不会影响单线程语义，但会破坏多线程语义，导致发布对象处在一个不一致的状态。</p>
<h3 id="Java-final-对比-kotlin-val"><a href="#Java-final-对比-kotlin-val" class="headerlink" title="Java final 对比 kotlin val"></a>Java final 对比 kotlin val</h3><p>​        在声明变量时，final同val一样只能一次赋值。但是在属性声明时却存在一定的差异</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">17</span></span><br><span class="line">    <span class="comment">// 通过get调用isAdult的结果是可变的。</span></span><br><span class="line">    <span class="keyword">val</span> isAdult: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是final就做不到</span></span><br><span class="line"><span class="comment">// 然而final声明的变量只要在构造方法之前去实例化就行。但是val声明就必须指定</span></span><br></pre></td></tr></table></figure>

<p>​        在方法中的参数，kotlin默认使用的就是val修饰。而在java中必须显示指定final才能达到相同效果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 报错：val cannot be reassigned</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过编译</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">final</span> String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 报错Cannot assign a value to final variable &#x27;s&#x27;</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>　　从开头到结束一直在强调final修饰不可变。就比如不可变类String类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]; <span class="comment">// 实际存值得数组</span></span><br></pre></td></tr></table></figure>

<p>我们依然可以通过反射的方式去修改String的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s = <span class="string">&quot;modify me!!!!!&quot;</span>;</span><br><span class="line">    modifyStr(s);</span><br><span class="line">    System.out.println(s);<span class="comment">//输出 modify success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modifyStr</span><span class="params">(String s)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取String类中的value字段</span></span><br><span class="line">    Field field = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.在用反射时访问私有变量，需设置为true</span></span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 3.接收该String对象存的value值</span></span><br><span class="line">    <span class="keyword">char</span> value[]= (<span class="keyword">char</span>[]) field.get(s);</span><br><span class="line">    <span class="comment">// 4.通过数组索引赋值修改</span></span><br><span class="line">    String modify = <span class="string">&quot;modify success&quot;</span>;</span><br><span class="line">    <span class="comment">// 注意：这儿只能在数组原始对象长度范围内操作，不能新建对象扩容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        value[i] = modify.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是反射不是用来处理这些问题，而是为了拿到某些<code>private</code>字段或者私有方法而修改成自己想要的样式。同样的反射拿到的可能是一个final类型的数据。就可以像上述一样去修改。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
</search>
