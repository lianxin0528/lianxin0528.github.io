<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Kotlin标准库函数let，apply，with，run，also</title>
    <url>/2020/11/02/Kotlin%20Basic%20Function/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>　　相比较于Java，在Kotlin中提供了许多的内置函数来帮助开发者写出更优雅的代码，同样的逻辑，在Kotlin中可以有更好的表达，当然你也可以不使用这些函数。</p>
<p>　　要弄明白这几个函数的具体使用，我们只需要从三个角度：是不是扩展函数？、返回值是什么？、this指的是谁？。只要弄清楚了这三点就理解了let,apply等函数。代码使用了lambda表达式，如果不清楚lambda表达式和扩展函数的可以参考下面的链接。</p>
<blockquote>
<p><a href="https://kaixue.io/kotlin-lambda/">Kotlin 的 Lambda 表达式，大多数人学得连皮毛都不算</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.kotlincn.net/docs/reference/extensions.html">Kotlin中文官方文档-扩展函数</a></p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>　　我们一开始就说了这些函数是为了让代码看起来更加的简洁，所以这些函数没有实现任何功能，即使不会也不会影响编码。但是别人用了你看不懂这就不好吧。</p>
<p>　　在学习使用过程中我们带着上述的三个问题。因为这几个函数有很多相似性，所以我重点介绍<code>let</code>函数和<code>apply</code>函数。当我们能够清晰的使用者两个函数时，其他函数也就不在话下。</p>
<h4 id="let的使用"><a href="#let的使用" class="headerlink" title="let的使用"></a>let的使用</h4><p>　　<code>let()</code>的定义是这样的，默认当前这个对象作为闭包(代码块)的it参数，返回值是函数里面最后一行。知道定义后看看let函数是去替换怎样的一种写法呢。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> activityMainTopTitle = findViewById&lt;TextView&gt;(R.id.activityMainTopTitle)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line">activityMainTopTitle.text = <span class="string">&quot;title&quot;</span></span><br><span class="line"><span class="comment">// ...更多的一些设置</span></span><br><span class="line">activityMainTopTitle.setBackgroundColor(Color.RED)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换用let的写法</span></span><br><span class="line">activityMainTopTitle.let &#123;</span><br><span class="line">    it.text = <span class="string">&quot;title&quot;</span></span><br><span class="line">    <span class="comment">// ...更多的一些设置</span></span><br><span class="line">    it.setBackgroundColor(Color.RED)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我个人一般不会这样去使用let，这样反而让代码变得不那么简洁（个人感觉，但是可读性变高了，可读性变高了不也是一种简洁么?）。多数情况下使用<code>?.let</code>的形式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList2: MutableList&lt;<span class="built_in">Int</span>&gt;? = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line"><span class="keyword">if</span> (mutableList2 != <span class="literal">null</span>) &#123;</span><br><span class="line">    mutableList2.add(<span class="number">1</span>)</span><br><span class="line">    mutableList2.add(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换用let的写法。</span></span><br><span class="line"><span class="comment">// 表示mutableList2不为null的条件下，才会去执行let函数体</span></span><br><span class="line">mutableList2?.let &#123;</span><br><span class="line">    it.add(<span class="number">1</span>)</span><br><span class="line">    it.add(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啊这，那我要是要处理为空的情况呢，是不是就不能使用let了？ 有得，有得。如果要实现<code>if-else</code>结构，你可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mutableList2?.let &#123;</span><br><span class="line">    it.add(<span class="number">1</span>)</span><br><span class="line">    it.add(<span class="number">2</span>)</span><br><span class="line">&#125; ?: let &#123;</span><br><span class="line">    <span class="comment">// mutableList2为空又怎么撸。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的一点就是<code>?.let</code>只能去实现<code>if-else</code>中非空判断的逻辑，其他情况还是做不到呢。最后我们看一下let函数的声明：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let函数声明（去掉契约contract部分，对实际实现无影响，方便理解。下同）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上面的代码和函数声明是不是对let的认识又清晰了很多呢，为了更好的回答上面的三个问题。我截取了Android Studio中的代码帮助大家理解：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/02/lzmDuJfXRKG8w6r.png" alt="KotlinNormal_let_1"></p>
<p>　　总结一下：let函数是一个扩展函数，其返回值是代码块最后一行。若最后一行没有返回值则返回值为<code>Unit</code>。在代码块中的this指代的是当前类对象。</p>
<h4 id="apply的使用"><a href="#apply的使用" class="headerlink" title="apply的使用"></a>apply的使用</h4><p>　　看完了let，现在来看看apply函数的使用：apply函数可以在函数内调用该对象的任意方法，并返回该对象，依然先看看常规写法和等价写法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList = mutableListOf&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line">mutableList.add(<span class="number">1</span>)</span><br><span class="line">mutableList.add(<span class="number">2</span>)</span><br><span class="line">mutableList.remove(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换用apply写法</span></span><br><span class="line">mutableList.apply &#123;</span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>)</span><br><span class="line">    remove(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>let函数是it作为参数传进来，apply怎么变成了this，而且直接调用了<code>add()</code>方法？别急，先看看在Android Studio中是什么样的。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/02/8BindhsRYIDPqlE.png" alt="KotlinNormal_apply_1"></p>
<p>对比let函数，可以发现apply传入的参数名由<code>it</code>变成了<code>this</code>(但是他们指代的对象都是<code>mutableList</code>)，并且在函数内部this指代的对象也从<strong>类对象</strong>变成了<strong>当前对象</strong>。首先，我们知道<code>this</code>是具有特殊意义的。其次，我们也知道通过<code>this.method()</code>方式调用方法是可以省略<code>this</code>的，所以这也就是apply函数定义中的<strong>可以在函数内调用该对象的任意方法</strong>（私有方法还是不行哦）。最后来看一下apply函数和let函数的声明：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apply函数的声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啊？，这<code>T.()</code>是个什么啊？我们只见过<code>block: (T) -&gt; Unit</code>和<code>block: () -&gt; Unit</code>。也没有见过<code>block: T.() -&gt; Unit</code>啊！T不一个类么？怎么可以直接<code>T.()</code>呢？</p>
<p>　　我们看看文档的描述：</p>
<blockquote>
<p>　　这个函数接受一个名为<code>init</code>的参数，该参数本身就是一个函数。该函数的类型就是<code>T.() -&gt; Unit</code>这意味着我们需要向函数传递一个T类型的实例，并且我们可以在函数内部调用该实例的成员。并且可以通过this关键字访问。</p>
</blockquote>
<p>如果不懂也没有关系，我们只要记住<code>T.() -&gt; Unit</code>这是一个类型，并且函数体内部使用this关键字访问。这就是造成let和apply函数中传入的参数一个是it，一个是this的原因。我们就不详细讲解这个了。感兴趣的可以自行谷歌。</p>
<p>　　总结一下：apply函数是一个扩展函数。从截图中<code>returnResult</code>的类型也可以很明显看出来：其返回值就是当前对象。在代码块中的this指代的是调用apply函数的实例对象。</p>
<h4 id="with的使用"><a href="#with的使用" class="headerlink" title="with的使用"></a>with的使用</h4><p>　　从使用上来看with函数更像是let + apply函数。但是因为with函数是唯一的一个非扩展函数。所以在写法上和其他函数还是有一点差异。我们还是先看看实际的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList: MutableList&lt;<span class="built_in">Int</span>&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常写法</span></span><br><span class="line">mutableList.add(<span class="number">1</span>)</span><br><span class="line">mutableList.add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> returnResult = <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换用with写法</span></span><br><span class="line"><span class="keyword">val</span> returnResult = with(mutableList) &#123;</span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>)</span><br><span class="line">    <span class="string">&quot;3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道函数都有<code>object?.method()</code>的形式去调用，表示object不为null时才去调用方法。with怎么去实现<code>?.</code>的调用形式。可以参考如下形式，这是我个人写的比较多的一种形式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mutableList2: MutableList&lt;<span class="built_in">Int</span>&gt;? = mutableListOf()</span><br><span class="line">with(mutableList2 ?: <span class="keyword">return</span>) &#123;</span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是需要注意的是：这行with语句应该放在最后，即<strong>在with之后不会有代码需要执行</strong>。因为当<code>mutableList2</code>为null时会执行return结束整个方法的执行。如果后面还有代码需要执行的话还是老老实实的做非空判断吧。</p>
<p>　　总结一下：with = let + apply。with是唯一的一个非扩展函数。返回值和let一样是代码块最后一行。this指代的对象和apply一样是当前对象。</p>
<h4 id="run的使用"><a href="#run的使用" class="headerlink" title="run的使用"></a>run的使用</h4><p>　　run函数的定义和apply函数的定义很像，区别在于apply函数的返回值是当前对象，而run函数返回值是代码块最后一行。</p>
<h4 id="also的使用"><a href="#also的使用" class="headerlink" title="also的使用"></a>also的使用</h4><p>　　also函数的定义和let函数定义很像，区别在于let函数的返回值是代码块最后一行，而also的返回值是当前对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　没了？没了。真的没了！其实只要理解清楚了let函数和apply函数，基本就全部都清楚了。从其函数声明上就可以看出他们有许多相似之处。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// apply函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// with函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// run函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// also函数声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给张表格清晰的对比它们之间的区别：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">是否为扩展函数</th>
<th align="center">返回值</th>
<th align="center">this指代的对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">let</td>
<td align="center">true</td>
<td align="center">代码块最后一行</td>
<td align="center">当前类对象</td>
</tr>
<tr>
<td align="center">apply</td>
<td align="center">true</td>
<td align="center">当前对象</td>
<td align="center">调用apply的对象</td>
</tr>
<tr>
<td align="center">with</td>
<td align="center">false</td>
<td align="center">代码块最后一行</td>
<td align="center">传入with的对象</td>
</tr>
<tr>
<td align="center">run</td>
<td align="center">true</td>
<td align="center">代码块最后一行</td>
<td align="center">调用run的对象</td>
</tr>
<tr>
<td align="center">also</td>
<td align="center">true</td>
<td align="center">当前对象</td>
<td align="center">当前类对象</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin中的操作符和部分关键字</title>
    <url>/2021/01/05/KotlinOperator/</url>
    <content><![CDATA[<h3 id="操作符-运算符-重载"><a href="#操作符-运算符-重载" class="headerlink" title="操作符(运算符)重载"></a>操作符(运算符)重载</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>操作符重载就是对预定义操作符赋予他们新的含义。重载的修饰符是operator</p>
</blockquote>
<p>　　什么是预定义操作符呢？举个例子，<code>+</code>号就是预定义操作符，对应的函数名就是<code>plus</code>。他的预先含义就是两个数值相加或者两个字符串相加返回一个新的值。我们可以使用<code>operator</code>操作符去实现自己的想要的功能。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>　　我们先看一段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">M</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> M.<span class="title">plus</span><span class="params">(other: <span class="type">M</span>)</span></span>: M &#123;</span><br><span class="line">    <span class="keyword">return</span> M(a + other.a, b + other.b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用处代码</span></span><br><span class="line"><span class="keyword">val</span> newM = M(<span class="number">1</span>, <span class="number">2</span>) + M(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>对于类M，我们重载了<code>+</code>号操作符，并且实现自己想要的内容。当然other的类型也可以是其他类型。这两个的类型不一定要一致，甚至你可以连返回值不一致。从某种意义上来讲这就是扩展函数。只不过你可以使用预定义的符号来代替你的函数名。</p>
<p>　　我们重载操作符主要是为了开发方便。例如你可以这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">plus</span><span class="params">(other: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> toMutableList().apply &#123; addAll(other) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用处代码</span></span><br><span class="line"><span class="keyword">val</span> list1: List&lt;M&gt; <span class="comment">// 某个处理得到的值</span></span><br><span class="line"><span class="keyword">val</span> list2: List&lt;M&gt; <span class="comment">// 某个处理得到的值</span></span><br><span class="line"><span class="keyword">val</span> newList = list1 + list2</span><br></pre></td></tr></table></figure>

<p>同样的你还可以去实现其他的操作符。</p>
<h4 id="常用的操作符和对应函数名"><a href="#常用的操作符和对应函数名" class="headerlink" title="常用的操作符和对应函数名"></a>常用的操作符和对应函数名</h4><table>
<thead>
<tr>
<th align="center"><strong>表达式</strong></th>
<th align="center"><strong>函数名</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">+a</td>
<td align="center">a.unaryPlus()</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">a.unaryMinus()</td>
</tr>
<tr>
<td align="center">!a</td>
<td align="center">a.not()</td>
</tr>
<tr>
<td align="center">a++</td>
<td align="center">a.inc()</td>
</tr>
<tr>
<td align="center">a–</td>
<td align="center">a.dec()</td>
</tr>
<tr>
<td align="center">a + b</td>
<td align="center">a.plus(b)</td>
</tr>
<tr>
<td align="center">a - b</td>
<td align="center">a.minus(b)</td>
</tr>
<tr>
<td align="center">a * b</td>
<td align="center">a.times(b)</td>
</tr>
<tr>
<td align="center">a / b</td>
<td align="center">a.div(b)</td>
</tr>
<tr>
<td align="center">a % b</td>
<td align="center">a.rem(b)，<del>a.mod(b)</del></td>
</tr>
<tr>
<td align="center">a..b</td>
<td align="center">a.rangeTo(b)</td>
</tr>
<tr>
<td align="center">a in b</td>
<td align="center">b.contains(a)</td>
</tr>
<tr>
<td align="center">a += b</td>
<td align="center">a.plusAssign(b)</td>
</tr>
<tr>
<td align="center">a -= b</td>
<td align="center">a.minusAssign(b)</td>
</tr>
<tr>
<td align="center">a *= b</td>
<td align="center">a.timesAssign(b)</td>
</tr>
<tr>
<td align="center">a /= b</td>
<td align="center">a.divAssign(b)</td>
</tr>
<tr>
<td align="center">a %= b</td>
<td align="center">a.remAssign(b)，<del>a.modAssign(b)</del></td>
</tr>
</tbody></table>
<p>　　操作符还有一些我就不写了，需要值得注意的是<code>in</code>的操作符重载返回值必须是<code>Boolean</code>类型。对于如<code>+=</code>增量赋值等操作符返回值必须是<code>Unit</code>。如果记不清楚也没有关系，当你打出<code>operator</code>关键字的时候IDE会有提示。</p>
<p>最后附上官网地址</p>
<blockquote>
<p><a href="https://kotlinlang.org/docs/reference/operator-overloading.html">操作符重载 Operator overloading</a></p>
</blockquote>
<h3 id="部分关键字"><a href="#部分关键字" class="headerlink" title="部分关键字"></a>部分关键字</h3><h4 id="infix函数-中缀方法"><a href="#infix函数-中缀方法" class="headerlink" title="infix函数(中缀方法)"></a>infix函数(中缀方法)</h4><p>中缀方法其实和我们上面讲到的操作符重载有点像，不过与操作符重载不同的是，infix是我们自己定义的函数名称，然后像操作符一样的去使用他。</p>
<p>　　<code>infix</code>函数构成条件：</p>
<ul>
<li>参数列表只能有一个参数</li>
<li>必须是成员方法或者是扩展方法</li>
<li>使用<code>infix</code>修饰</li>
</ul>
<p>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个中缀函数</span></span><br><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">add</span><span class="params">(other: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> + other</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 像二元操作符一样的去使用它</span></span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = <span class="number">1</span> add <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这其实算是自定义操作符了吧（O(∩_∩)O哈哈~）不过也不算哈。因为要满足变量的命名规则。</p>
<h4 id="tailrec尾递归优化"><a href="#tailrec尾递归优化" class="headerlink" title="tailrec尾递归优化"></a>tailrec尾递归优化</h4><p>首先要理解的就是什么是尾递归：return除了调用自身，没有其余的操作我们把它称之为尾递归。<code>tailrec</code>是提醒编译器这是一个尾递归函数。在编译的时候可以将压栈弹栈转化为循环操作避免内存溢出。</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title>基于MvRx+Epoxy的MvRx的MVVM</title>
    <url>/2020/09/15/MVVM/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　MVVM是Model-View-ViewModel的简写。是一个推出来很久并且已经非常成熟的框架。相比较于与MVC好处很多就不赘述了。重点在于当前使用的MVP框架和MVVM做比较。首先看一哈MVVM的大体结构。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/03/08/Fhan2SiD81ypLWU.jpg" alt="mvrx_mvvm">)</p>
<p>其中每个模块都有自己明确的分工，各司其职。</p>
<ul>
<li><strong>Activity</strong></li>
</ul>
<p>　　activity不在意数据的来源，只负责将ViewModel中的数据绑定到UI。是一个管理者，简言之就是activity的代码几乎都是和UI相关的。</p>
<ul>
<li><strong>ViewModel</strong></li>
</ul>
<p>　　ViewModel不在意界面如何展示，只负责处理数据。并将处理好的数据放到数据集合中，并且通知activity数据已经处理完毕。从这点来说，一个ViewModel更像一个工人，用来处理某一种或者某一类数据。对应在我们的项目中就是一个小模块的数据（或者说是某个接口数据）。当前我们的MVP框架对于多个Activity调用同一个接口需要重复去完成这项工作。但是对于ViewModel来说，它可以提供给多个activity使用，因为它只负责处理数据。让一个Activity依赖多个ViewModel。来共同完成界面的显示工作。</p>
<ul>
<li><strong>Repostory</strong></li>
</ul>
<p>　　repostory就是仓库的意思。这是一个数据仓库。ViewModel需要处理的原始数据均从Repostory中获取，repostory主要负责协调本地数据和远端数据。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>　　我在搭建框架的时候看了许多东西，从中选择，有些好的我也是现学的。不一定理解到位了，如有错误还请指正。</p>
<h4 id="Kodein"><a href="#Kodein" class="headerlink" title="Kodein"></a>Kodein</h4><blockquote>
<p><a href="https://github.com/Kodein-Framework/Kodein-DI">依赖注入框架Kedein连接</a></p>
</blockquote>
<p>　　为什么选择kodein是因为它注入方便。使用也方便。我们看实际代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注入</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> TAG_KODEIN_MODULE_REPOSITORY_OAUTH = <span class="string">&quot;oauthRepositoryModel&quot;</span></span><br><span class="line"><span class="keyword">val</span> oauthRepositoryModel = Kodein.Module(TAG_KODEIN_MODULE_REPOSITORY_OAUTH) &#123;</span><br><span class="line">    bind&lt;OauthRemoteDataSource&gt;() with singleton &#123; OauthRemoteDataSource() &#125;</span><br><span class="line">    bind&lt;OauthRepository&gt;() with singleton &#123; </span><br><span class="line">        OauthRepository(instance(), instance())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> oauthRepo <span class="keyword">by</span> BaseApplication.INSTANCE.kodein.instance&lt;OauthRepository&gt;()</span><br></pre></td></tr></table></figure>

<p>这代码看着相对于Dagger变复杂了。其实并没有变得复杂。数据仓库是我们很多地方都需要调用的。kodein的好处就在于任何地方都可以注入，任何地方都可以得到实例化对象。除了singleton之外还有别的注入方式。</p>
<ul>
<li><p>Provider binding : 每次加载都生成新的实例，无参， 传入<code>() -&gt; T</code></p>
</li>
<li><p>Singleton binding : 单例 传入 <code>() → T</code></p>
</li>
<li><p>Eager singleton : 单例 创建了 Kodein 实例后立即实例化 传入 <code>() -&gt; T</code></p>
</li>
<li><p>Factory binding : 每次加载都生成新的实例，需要参数，传入<code>(A) -&gt; T</code></p>
</li>
<li><p>Multiton binding : 有参的单例，同样参数同样实例，传入 <code>(A) -&gt; T</code></p>
</li>
<li><p>Tagged bindings : 通过 tag 来区分同类型不同的实例</p>
</li>
</ul>
<h4 id="哆啦A梦"><a href="#哆啦A梦" class="headerlink" title="哆啦A梦"></a>哆啦A梦</h4><blockquote>
<p><a href="https://www.dokit.cn/">android/Ios调试工具</a></p>
</blockquote>
<p>　　这个工具我是偶然间看到了，真的强推，很好用的一个工具。这其中提供的一些我觉得很强大的功能，着重说一哈里面有一个流量的工具，可以查看手机的流量情况和发出的每一个请求，并且能够查看请求的请求体和响应体。Crash和log也都是比较好的工具。DBView（虽然我们项目没有使用，但是也是一个强大的功能）</p>
<p>　　因为在项目中没有去做网络日志，所以使用多啦A梦工具，电脑端可以配合Charles来使用更好。</p>
<h3 id="utilcode"><a href="#utilcode" class="headerlink" title="utilcode"></a>utilcode</h3><blockquote>
<p><a href="https://blog.csdn.net/yhd007/article/details/88015556">AndroidUntilCode部分使用，有些他也没有介绍到</a></p>
</blockquote>
<p>　　这是一个工具类集合，基本上你想的到的想不到的工具类都能在这里找到。</p>
<h4 id="Epoxy-MvRx"><a href="#Epoxy-MvRx" class="headerlink" title="Epoxy+MvRx"></a>Epoxy+MvRx</h4><blockquote>
<p><a href="https://github.com/airbnb/epoxy">Epoxy</a></p>
<p><a href="https://github.com/airbnb/mavericks">MvRx，过完年这个家伙改名了，现在叫Mavericks</a></p>
</blockquote>
<p>　　最后讲到我们的主角，东西很多，我们结合代码讲。主要还是这几个方面。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建item</span></span><br><span class="line"><span class="comment">// 关联滑动事件</span></span><br><span class="line"><span class="comment">// 网络请求的几种方式</span></span><br><span class="line"><span class="comment">// 值的订阅</span></span><br><span class="line"><span class="comment">// 记录建议和改进的地方。</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：final关键字</title>
    <url>/2020/09/30/Java%20final/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>　　final是Java中的一个关键字，可以修饰类、方法、成员变量和局部变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 修饰内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123; <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;&#125; &#125;</span><br><span class="line"><span class="comment">// 修饰方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 修饰成员变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> filed = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 修饰方法参数（局部变量）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">final</span> String filed)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>　　当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你<strong>永远不会</strong>让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p>
<p>　　final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此方法不能被重写（可以重载多个final修饰的方法）。此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。也就是说子类是不能够存在和父类一模一样的方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(String filed)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">extendFinalClass</span> <span class="keyword">extends</span> <span class="title">FinalClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 因为父类为private方法，子类无法继承到，所以这是子类全新的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 可以重载父类的final方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 报错：override method is final</span></span><br><span class="line"><span class="comment">//	public final void method2(String filed) &#123;&#125;</span></span><br><span class="line">	<span class="comment">// 报错：override method is final</span></span><br><span class="line"><span class="comment">//	public void method2(String filed) &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后补充一句就是所有的private方法都会被隐式指定为final。</p>
<p>　　final成员变量表示常量，只能被赋值一次，赋值后值不再改变。当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求的值是<strong>地址的值</strong>不发生变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> filed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 引用不可变</span></span><br><span class="line">		<span class="keyword">final</span> FinalClass2 fc = <span class="keyword">new</span> FinalClass2();</span><br><span class="line">		System.out.println(fc.filed); <span class="comment">// 输出0</span></span><br><span class="line">		fc.filed = <span class="number">1</span>;</span><br><span class="line">		System.out.println(fc.filed); <span class="comment">// 输出1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="为什么要使用final"><a href="#为什么要使用final" class="headerlink" title="为什么要使用final?"></a>为什么要使用final?</h4><p>　　我们利用final加以修饰，无外乎两个原因，一个是设计原因，一个是效率原因，这是由于在不同的环境下final 有着不同的语义，所以可能会带来它的一些误解与误用。</p>
<ul>
<li><p><strong>设计原因</strong></p>
<p>　　从设计的角度来考虑为final类，此时final 的语义表明为：<strong>这个类不想在关系结构上做出任何的改变，也不希望有任何人可以继承自这个类，除此之外，就没有更多的限制了。</strong>例如：JDK中提供的基本数据包装类和String类就是final类。以上是我们从类的设计角度来考虑类被final 修饰的情况。此时，我们还需要注意一点，一个类被final之后，它就禁止了继承关系，那么一个这个类中的所有方法都是final修饰的，因为他们不会再被重写了。</p>
</li>
<li><p><strong>效率原因</strong></p>
<p>　　在我们说明final如何在效率上起到作用的时候，我们首先需要掌握一个知识点，即<strong>方法的内联</strong>。我们在掌握了这个知识点之后，可能对于对于final 修饰方法也就一并掌握了。我们要说明final为一个类（Class）带来效率上的好处，还真的得研究到蛮深入的地步，这个深入的地步可以到JVM对于方法的调用处理，也可以深入到寄存器如何存储指令，在这里我们就一切从简的说。</p>
</li>
</ul>
<p>　　一个类被final修饰后，它的方法默认被修饰为final ，这时方法的内联起到作用了。对于Java语言的编译器来说，我们无需刻意地利用内联做什么，编译器会自动地进行函数内联优化。什么是方法的内联呢？一句话直白的说就是把函数调用的方法直接内嵌到方法内部，减少函数调用的次数。实际就是（copy + replace）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = car.getPrice();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    z = car.getPrice();</span><br><span class="line">    discount = y - z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联之后的代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDiscount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y = car.price;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    z = car.price;</span><br><span class="line">    discount = y - z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种很典型的空间换时间的策略。</p>
<h4 id="final修饰域（Field）"><a href="#final修饰域（Field）" class="headerlink" title="final修饰域（Field）"></a>final修饰域（Field）</h4><p>​        final修饰域无外乎两种，一种是基本数据类型的数据域，一种是引用类型。首先是基本数据类型，这个是最常见的使用方法了。用法很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORDER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fee = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​        我认为final修饰基本数据类型的时候是最能体现final语义的一个用法。 出于以下两点考虑的时候，我们就要用final来修饰一个基本数据类型。</p>
<ol>
<li><p>程序编译期间的常量，它永远不会变。</p>
</li>
<li><p>在运行期间为一个final修饰的域初始化一个值，不希望它会发生变化。</p>
</li>
</ol>
<p>这两点对应代码块中的第一条和第二条。在这里补充一点堆、栈和常量池的相关知识。</p>
<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/20/eYKk91aBnxVJzFi.png" alt="堆栈图" style="zoom: 90%;" />

<p>​        一个被final修饰的域就会被放在常量池中，这么做的原因就是为了提高效率。常量值装在需要计算的过程中，让它们充当类似于宏的身份，换句话说，编译器可以在编译期间提前完成一些计算工作，省去了在运行时对于变量的相对复杂的操作。对于static和没有static修饰的基本数据类型来说，是有差异的，差异就在于static修饰的域是在类载入的时候进行初始化的，所有实例共享同一个常量，同时Java虚拟机没有把它当作类变量，在使用它的任何类的常量池或者字节码流中直接存放的是它表示的常量值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码块展示初始化过程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> b;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// static final 只能在这里初始化或直接赋值</span></span><br><span class="line">  <span class="keyword">static</span> &#123; a = <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="comment">// 动态代码块初始化</span></span><br><span class="line">  &#123; b = <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="comment">// 构造函数初始化</span></span><br><span class="line">  DateTest()&#123; c = <span class="number">3</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        对于引用类型来说，如果有final修饰一个引用类型变量，不是说明这个引用类型指向的实际地址的对象不可变，而是说这个引用不能再指向其他地址的对象，而对象本身是可以改变的。前面也说差不多，这确实有点迷惑。不过问题也不大，就说明一个变量的引用不能变而已，被固定了。对于这点，我就不做过多的解释了。</p>
<h4 id="final修饰方法参数"><a href="#final修饰方法参数" class="headerlink" title="final修饰方法参数"></a>final修饰方法参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalField</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FinalFieldClass ffc = <span class="keyword">new</span> FinalField().getObject(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">    System.out.println(ffc.getStr());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> FinalFieldClass <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalFieldClass() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// variable &#x27;str&#x27; is accessed from within inner class, needs to be declare final</span></span><br><span class="line">        <span class="comment">// 变量&#x27;str&#x27;是从内部类内部访问的，需要声明为final</span></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalFieldClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getStr</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        final修饰方法参数，这里使用内部类来举例。我们跟着main函数执行顺序走，首先创建了一个<code>FinalField</code>对象，调用这个对象的<code>getObject()</code>方法，获取一个对象返回。假设现在这个<code>getObject()</code>方法没有加<code>final</code>关键字。首先将<code>str</code>压栈，创建了一个<code>FinalFieldClass</code>子类对象并返回。此时<code>getObject()</code>方法结束了，返回一个<code>ffc</code>对象，相应的局部变量就应该弹栈，也就是说<code>str</code>出栈了，栈中没有了<code>str</code>。那么问题来了，我现在去调用用<code>ffc</code>对象去调用<code>getStr()</code>方法。就获取不到对应的值了。但是JVM不会这么做，他会在弹出<code>str</code>的时候，就会拷贝一份<code>str</code>的值，当我们创建<code>FinalFieldClass</code>对象时将这个值存放在名为<code>str</code>的变量中，编译器必须检测对局部变量的访问，为每一个变量建立对应的数据域，并将局部变量拷贝到构造器中。</p>
<p>​        那么我们将方法参数列表中的变量修饰为final的，防止了这个变量<strong>在方法中被修改</strong>，因此就做到了局部变量与在内部类建立的拷贝副本保持了一致。而且在java8中已经可以不显示的使用final修饰。会被默认的指定为final。</p>
<h3 id="final在多线程"><a href="#final在多线程" class="headerlink" title="final在多线程"></a>final在多线程</h3><p>​        上面讲述的内容都是属于java的基础层面。后面我们看看在多线程中的final，final会进行怎么样的重排序，是否会导致线程安全问题。</p>
<h4 id="final域重排序规则"><a href="#final域重排序规则" class="headerlink" title="final域重排序规则"></a>final域重排序规则</h4><p>　　重排序是编译器或者CPU的代码的结构重排序，达到最佳效果。举个简单的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">int</span> a1 = x * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = y * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = y * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重排序之后的代码</span></span><br><span class="line"><span class="keyword">int</span> a1 = x * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = y * <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b2 = y * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>CPU只读一次的x和y值。不需反复读取寄存器来交替x和y值。</p>
<p>　　在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两初次读一个包含final域对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
<h5 id="final域为基本类型"><a href="#final域为基本类型" class="headerlink" title="final域为基本类型"></a>final域为基本类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> a;  <span class="comment">// 普通域</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b; <span class="comment">// final域</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> FinalDemo finalDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>; <span class="comment">// 1.写普通域</span></span><br><span class="line">    b = <span class="number">2</span>; <span class="comment">// 2.写final域</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finalDemo = <span class="keyword">new</span> FinalDemo();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FinalDemo demo = finalDemo; <span class="comment">// 3.读对象引用</span></span><br><span class="line">    <span class="keyword">int</span> a = demo.a;    <span class="comment">// 4.读普通域</span></span><br><span class="line">    <span class="keyword">int</span> b = demo.b;    <span class="comment">// 5.读final域</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设线程A在执行<code>writer()</code>方法，线程B执行<code>reader()</code>方法。</p>
<p>　　在写一个final域的时候，JMM会禁止将写final的代码重排序到构造函数之外。通过在写final域之后和构造函数完成之前添加一个storestore内存屏障来实现。当线程A调用调用<code>writer()</code>方法时，首先创建一个<code>FinalDemo</code>对象，并将这个对象的引用赋值给<code>finalDemo</code>。如果现在线程B没有重排序，可能执行的时序图如下：</p>
<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/20/VFJ3A1Uu9cYMODx.png" alt="可能时序" style="zoom: 67%;" />



<p>​        由于a,b之间没有数据依赖性，普通域（普通变量）a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值（零值），这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。在读一个final域的时候，根据前面的规则，就是3一定会发生在5之前。</p>
<h5 id="final域为引用类型"><a href="#final域为引用类型" class="headerlink" title="final域为引用类型"></a>final域为引用类型</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span>[] arrays;</span><br><span class="line">  <span class="keyword">private</span> FinalReferenceDemo finalReferenceDemo;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    arrays = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];  <span class="comment">//1</span></span><br><span class="line">    arrays[<span class="number">0</span>] = <span class="number">1</span>;        <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finalReferenceDemo = <span class="keyword">new</span> FinalReferenceDemo(); <span class="comment">//3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    arrays[<span class="number">0</span>] = <span class="number">2</span>;  <span class="comment">//4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finalReferenceDemo != <span class="keyword">null</span>) &#123;  <span class="comment">//5</span></span><br><span class="line">      <span class="keyword">int</span> temp = finalReferenceDemo.arrays[<span class="number">0</span>];  <span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        针对引用数据类型，final域写针对编译器和处理器重排序<strong>增加</strong>了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。</p>
<p>​        线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论。</p>
<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/20/t5SVqZvUldzFke4.png" alt="可能时序" style="zoom:80%;" />

<p>​        由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>基本数据类型:</strong><br>        final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。<br>        final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。</p>
<p><strong>引用数据类型：</strong><br>        额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序</p>
<p>​        final类型的变量可以保证在多线程发布某个对象时，这个对象的final域变量能够被正常的初始化（在写final变量后加了storestore屏障，在读final变量前加了loadload屏障），而普通类型的变量可能不会被正确的初始化，这样导致该对象在多个线程之间出现不一致的情况，这也就是我们所说的引用溢出。罪魁祸首是处理器重排序，因为处理器重排序不会影响单线程语义，但会破坏多线程语义，导致发布对象处在一个不一致的状态。</p>
<h3 id="Java-final-对比-kotlin-val"><a href="#Java-final-对比-kotlin-val" class="headerlink" title="Java final 对比 kotlin val"></a>Java final 对比 kotlin val</h3><p>​        在声明变量时，final同val一样只能一次赋值。但是在属性声明时却存在一定的差异</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">17</span></span><br><span class="line">    <span class="comment">// 通过get调用isAdult的结果是可变的。</span></span><br><span class="line">    <span class="keyword">val</span> isAdult: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是final就做不到</span></span><br><span class="line"><span class="comment">// 然而final声明的变量只要在构造方法之前去实例化就行。但是val声明就必须指定</span></span><br></pre></td></tr></table></figure>

<p>​        在方法中的参数，kotlin默认使用的就是val修饰。而在java中必须显示指定final才能达到相同效果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">method</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 报错：val cannot be reassigned</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过编译</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">final</span> String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 报错Cannot assign a value to final variable &#x27;s&#x27;</span></span><br><span class="line">    s = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>　　从开头到结束一直在强调final修饰不可变。就比如不可变类String类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[]; <span class="comment">// 实际存值得数组</span></span><br></pre></td></tr></table></figure>

<p>我们依然可以通过反射的方式去修改String的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s = <span class="string">&quot;modify me!!!!!&quot;</span>;</span><br><span class="line">    modifyStr(s);</span><br><span class="line">    System.out.println(s);<span class="comment">//输出 modify success</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modifyStr</span><span class="params">(String s)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取String类中的value字段</span></span><br><span class="line">    Field field = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.在用反射时访问私有变量，需设置为true</span></span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 3.接收该String对象存的value值</span></span><br><span class="line">    <span class="keyword">char</span> value[]= (<span class="keyword">char</span>[]) field.get(s);</span><br><span class="line">    <span class="comment">// 4.通过数组索引赋值修改</span></span><br><span class="line">    String modify = <span class="string">&quot;modify success&quot;</span>;</span><br><span class="line">    <span class="comment">// 注意：这儿只能在数组原始对象长度范围内操作，不能新建对象扩容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">        value[i] = modify.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是反射不是用来处理这些问题，而是为了拿到某些<code>private</code>字段或者私有方法而修改成自己想要的样式。同样的反射拿到的可能是一个final类型的数据。就可以像上述一样去修改。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>关键字</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
